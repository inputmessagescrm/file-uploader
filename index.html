<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Загрузка файлов для проверки</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; padding: 20px; }
    .container { max-width: 800px; margin: 0 auto; padding: 40px 20px; }
    .header { text-align: center; margin-bottom: 40px; color: white; }
    .header h1 { font-size: 2.5rem; font-weight: bold; margin-bottom: 16px;
      background: linear-gradient(45deg, #fff, #e0e7ff);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .header p { font-size: 1.125rem; opacity: 0.9; max-width: 680px; margin: 0 auto; }

    .user-info { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
      border-radius: 12px; padding: 20px; margin: 24px 0 30px;
      border: 1px solid rgba(255, 255, 255, 0.2); color: white; display: none; }
    .user-info h3 { font-size: 0.95rem; font-weight: 600; margin-bottom: 8px; opacity: 0.95; }
    .user-info p { font-size: 0.95rem; margin: 6px 0; }

    .upload-zone { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
      border: 2px dashed #d1d5db; border-radius: 12px; padding: 60px 40px;
      text-align: center; cursor: pointer; transition: all 0.3s ease; margin-bottom: 30px; }
    .upload-zone:hover { border-color: #667eea; background: rgba(255, 255, 255, 1);
      transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); }
    .upload-zone.drag-over { border-color: #667eea; background: rgba(102, 126, 234, 0.1);
      transform: scale(1.02); }
    .upload-icon { width: 64px; height: 64px; margin: 0 auto 20px;
      background: #667eea; border-radius: 50%; display: flex;
      align-items: center; justify-content: center; transition: all 0.3s ease; }
    .upload-zone:hover .upload-icon { background: #5a67d8; transform: scale(1.1); }
    .upload-zone.drag-over .upload-icon { background: #667eea; transform: scale(1.2); }
    .upload-title { font-size: 1.25rem; font-weight: 600; color: #374151; margin-bottom: 8px; }
    .upload-subtitle { color: #6b7280; margin-bottom: 16px; }
    .file-info { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
      border-radius: 12px; padding: 20px; margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3); display: none; }
    .file-details { display: flex; align-items: center; justify-content: space-between; }
    .file-left { display: flex; align-items: center; gap: 12px; }
    .file-icon { width: 40px; height: 40px; background: rgba(102, 126, 234, 0.1);
      border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #667eea; }
    .file-name { font-weight: 500; color: #374151; margin-bottom: 4px; }
    .file-size { font-size: 0.875rem; color: #6b7280; }
    .file-actions { display: flex; align-items: center; gap: 8px; }
    .check-icon { color: #10b981; }
    .remove-btn { background: none; border: none; color: #6b7280;
      cursor: pointer; padding: 4px; border-radius: 4px; transition: color 0.2s; }
    .remove-btn:hover { color: #ef4444; }
    .progress-container { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
      border-radius: 12px; padding: 20px; margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3); display: none; }
    .progress-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .progress-text { font-size: 0.875rem; font-weight: 500; color: #374151; }
    .progress-percent { font-size: 0.875rem; color: #6b7280; }
    .progress-bar { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
      border-radius: 4px; transition: width 0.3s ease; width: 0%; }
    .progress-filename { font-size: 0.75rem; color: #6b7280; }
    .upload-btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white;
      border: none; padding: 16px 32px; border-radius: 8px; font-size: 1rem; font-weight: 500;
      cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      display: block; margin: 0 auto; }
    .upload-btn:hover:not(:disabled) { transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6); }
    .upload-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    .hidden { display: none !important; }
    .toast { position: fixed; top: 20px; right: 20px; background: white;
      border-radius: 8px; padding: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      border-left: 4px solid #10b981; transform: translateX(400px); transition: transform 0.3s ease;
      z-index: 1000; max-width: 420px; }
    .toast.show { transform: translateX(0); }
    .toast.error { border-left-color: #ef4444; }
    .toast-title { font-weight: 600; color: #374151; margin-bottom: 4px; }
    .toast-message { color: #6b7280; font-size: 0.875rem; }
    #fileInput { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Загрузите файл для проверки</h1>
      <p>Допустимый формат PDF, TIFF, JPEG или PNG. Размер до 200&nbsp;Мб.</p>
    </div>

    <div id="userInfo" class="user-info">
      <h3>Информация:</h3>
      <div id="userDetails"></div>
    </div>

    <div id="uploadZone" class="upload-zone">
      <div class="upload-icon">
        <svg width="32" height="32" fill="white" viewBox="0 0 24 24">
          <path d="M14,2H6A2,2 0,0,0 4,4V20A2,2 0,0,0 6,22H18A2,2 0,0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
        </svg>
      </div>
      <h3 class="upload-title">Перетащите файл сюда</h3>
      <p class="upload-subtitle">или <span class="highlight">выберите файл</span> с компьютера</p>
      <!-- УБРАНО: <p class="upload-formats">...</p> -->
      <input type="file" id="fileInput" accept=".pdf,.tiff,.tif,.jpeg,.jpg,.png" multiple>
    </div>

    <div id="fileInfo" class="file-info"></div>

    <div id="progressContainer" class="progress-container">
      <div class="progress-header">
        <span class="progress-text">Загрузка файла...</span>
        <span class="progress-percent" id="progressPercent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <p class="progress-filename" id="progressFilename"></p>
    </div>

    <button id="uploadBtn" class="upload-btn hidden">Отправить на проверку</button>
  </div>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <!-- UTIF.js -->
  <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
  <!-- pdf-lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>

  <script>
    const WEBHOOK_URL = 'https://n8n.mdmprint.online/webhook/6a64b230-5b0c-46ad-b4d0-8830cbd95cc4';
    const ALLOWED_EXTENSIONS = ['pdf', 'tiff', 'tif', 'jpeg', 'jpg', 'png'];
    const MAX_FILE_SIZE = 200 * 1024 * 1024;
    const SIZE_TOL_MM = 3;          // допуск по габариту (мм) для PDF
    const RATIO_TOL = 0.02;         // допуск по отношению сторон (2%) для изображений

    let selectedFiles = [];
    let isUploading = false;
    // Всё, что можем извлечь из URL
    let urlParams = { chat_id:'', timestamp:'', bot:'', messageId:'', sides:'one', sheet:'', sizeLabel:'', bleed:null, jobVars:null };

    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const uploadBtn = document.getElementById('uploadBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    const progressPercent = document.getElementById('progressPercent');
    const progressFilename = document.getElementById('progressFilename');
    const userInfo = document.getElementById('userInfo');
    const userDetails = document.getElementById('userDetails');

    function init() {
      parseUrl();
      renderUserInfo();

      uploadZone.addEventListener('click', () => fileInput.click());
      uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('drag-over'); });
      uploadZone.addEventListener('dragleave', e => { e.preventDefault(); uploadZone.classList.remove('drag-over'); });
      uploadZone.addEventListener('drop', handleDrop);
      fileInput.addEventListener('change', handleFileInputChange);
      uploadBtn.addEventListener('click', handleUpload);
    }

    // --- helpers: извлечь параметры из URL (в том числе из job) ---
    function parseUrl() {
      const sp = new URLSearchParams(window.location.search);
      urlParams.chat_id   = sp.get('chat_id')   || '';
      urlParams.timestamp = sp.get('timestamp') || '';
      urlParams.bot       = sp.get('bot')       || '';
      urlParams.messageId = sp.get('messageId') || '';
      urlParams.sides     = sp.get('sides')     || 'one';
      urlParams.sheet     = sp.get('sheet')     || '';

      // job = JSON { type, params: [ "...", "--setvariable=name:value", ... ] }
      const jobStr = sp.get('job');
      if (jobStr) {
        try {
          const job = JSON.parse(decodeURIComponent(jobStr));
          const map = {};
          (job.params || []).forEach(p => {
            if (p.startsWith('--setvariable=')) {
              const rest = p.slice('--setvariable='.length);
              const idx = rest.indexOf(':');
              if (idx > 0) {
                const k = rest.slice(0, idx);
                const v = rest.slice(idx + 1);
                map[k] = parseVal(v);
              }
            }
          });
          urlParams.jobVars = map;
          urlParams.bleed = !!map['G_ONOFF_createBleedIfNeeded'];

          // Подпишем размер красиво
          const long = toNum(map['specification_long_size']);
          const short = toNum(map['specification_short_size']);
          urlParams.sizeLabel = humanSizeLabel(long, short);
        } catch (e) {
          console.warn('job parse error', e);
        }
      }
    }
    function parseVal(v) {
      if (v === 'true') return true;
      if (v === 'false') return false;
      const n = Number(v);
      return isNaN(n) ? v : n;
    }
    function toNum(v) { const n = Number(v); return isNaN(n) ? null : n; }

    // Сопоставление стандартных размеров
    function humanSizeLabel(long, short) {
      if (!long || !short) return '—';
      const pair = [long, short].sort((a,b)=>a-b); // [min,max]
      const [min, max] = pair;

      const table = {
        '76x105':'A7 105×76 мм',
        '105x146':'A6 105×146 мм',
        '146x210':'A5 146×210 мм',
        '210x297':'A4 210×297 мм',
        '297x420':'A3 297×420 мм',
        '210x210':'210×210 мм',
        '99x210':'99×210 мм',
        '90x50':'90×50 мм',
        '85x55':'85×55 мм',
      };
      const key = `${min}x${max}`;
      return table[key] || `Свой размер ${min}×${max} мм`;
    }

    function renderUserInfo() {
      const lines = [];
      if (urlParams.sizeLabel) lines.push(`<p>Размер изделия: ${urlParams.sizeLabel}</p>`);
      if (urlParams.bot === 'mockup') {
        lines.push(`<p>Тип печати: ${urlParams.sides === 'two' ? 'Двусторонняя' : 'Односторонняя'}</p>`);
      }
      if (urlParams.bot === 'layout') {
        if (urlParams.sheet === 'SRA3') lines.push('<p>Формат листа для раскладки: SRA3 450×320 мм</p>');
        else if (urlParams.sheet === '487x330') lines.push('<p>Формат листа для раскладки: 487×330 мм</p>');
      }
      if (typeof urlParams.bleed === 'boolean') {
        lines.push(`<p>Дорисовка вылетов: ${urlParams.bleed ? 'Да' : 'Нет'}</p>`);
      }
      if (lines.length) {
        userDetails.innerHTML = lines.join('');
        userInfo.style.display = 'block';
      }
    }

    // --- валидация габаритов ---
    function expectedSizeFromJob() {
      const j = urlParams.jobVars || {};
      const long = toNum(j['specification_long_size']);
      const short = toNum(j['specification_short_size']);
      if (!long || !short) return null;
      return { w: long, h: short }; // будем сравнивать с учётом поворота
    }

    async function validateAndAnalyzeFiles(files) {
      let pagesTotal = 0;
      let detailsHtml = '';
      const sides = urlParams.sides;
      const expected = expectedSizeFromJob();

      if ((sides === 'one' && files.length > 1) || (sides === 'two' && files.length > 2)) {
        showToast('Ошибка', 'Загружено слишком много файлов', 'error');
        return false;
      }

      for (let file of files) {
        if (file.size > MAX_FILE_SIZE) {
          showToast('Файл слишком большой', `${file.name} > 200MB`, 'error');
          return false;
        }
        const ext = file.name.split('.').pop().toLowerCase();
        let pages = 1;
        let sizeOk = true;
        let sizeNote = '';

        if (ext === 'pdf') {
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          pages = pdf.numPages;

          if (expected) {
            const page = await pdf.getPage(1);
            const vp = page.getViewport({ scale: 1 });
            // ширина/высота в pt → мм
            const wmm = vp.width * 25.4 / 72;
            const hmm = vp.height * 25.4 / 72;

            const [tw, th] = [expected.w, expected.h]; // в мм
            sizeOk = mmClose(wmm, hmm, tw, th, SIZE_TOL_MM);
            if (!sizeOk) {
              sizeNote = ` (ожидалось ~${tw}×${th} мм, получено ~${Math.round(wmm)}×${Math.round(hmm)} мм)`;
            }
          }
        } else if (ext === 'tif' || ext === 'tiff') {
          const arrayBuffer = await file.arrayBuffer();
          const ifds = UTIF.decode(arrayBuffer);
          pages = ifds.length;

          if (expected && ifds[0]) {
            const w = ifds[0].width, h = ifds[0].height;
            const ratioOk = ratioClose(w, h, expected.w, expected.h, RATIO_TOL);
            sizeOk = ratioOk;
            if (!ratioOk) sizeNote = ' (соотношение сторон не совпадает с выбранным форматом)';
          }
        } else {
          // jpg/png — после конвертации DPI не надёжен; проверим только соотношение сторон
          if (expected) {
            const img = await fileToImage(file);
            const ratioOk = ratioClose(img.width, img.height, expected.w, expected.h, RATIO_TOL);
            sizeOk = ratioOk;
            if (!ratioOk) sizeNote = ' (соотношение сторон не совпадает с выбранным форматом)';
          }
        }

        detailsHtml += `<p>${file.name} — ${pages} стр.${!sizeOk ? `<span style="color:#ef4444">${sizeNote}</span>` : ''}</p>`;
        pagesTotal += pages;

        if (sides === 'one' && pagesTotal > 1) {
          showToast('Ошибка', 'Для односторонней печати допустим только 1 файл = 1 страница', 'error');
          return false;
        }
        if (sides === 'two' && pagesTotal > 2) {
          showToast('Ошибка', 'Для двусторонней печати допустимы максимум 2 страницы', 'error');
          return false;
        }
        if (!sizeOk && ext === 'pdf') {
          showToast('Неверный размер страницы', `${file.name}${sizeNote}`, 'error');
          return false;
        }
        if (!sizeOk && (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'tif' || ext === 'tiff')) {
          showToast('Внимание', `Формат изображения может не соответствовать выбранному размеру${sizeNote}. Продолжайте только если уверены.`, 'error');
          return false;
        }
      }

      fileInfo.innerHTML = detailsHtml;
      fileInfo.style.display = 'block';
      uploadBtn.classList.remove('hidden');
      uploadZone.style.display = 'none';
      return true;
    }

    function mmClose(wmm, hmm, tw, th, tol) {
      // проверяем обе ориентации
      const ok1 = Math.abs(wmm - tw) <= tol && Math.abs(hmm - th) <= tol;
      const ok2 = Math.abs(wmm - th) <= tol && Math.abs(hmm - tw) <= tol;
      return ok1 || ok2;
    }
    function ratioClose(w, h, tw, th, tol) {
      const r1 = w / h, r2 = tw / th, r2v = th / tw;
      return Math.abs(r1 - r2) / r2 <= tol || Math.abs(r1 - r2v) / r2v <= tol;
    }
    function fileToImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function handleDrop(e) {
      e.preventDefault();
      uploadZone.classList.remove('drag-over');
      if (e.dataTransfer.files.length) {
        processFiles(e.dataTransfer.files);
      }
    }
    function handleFileInputChange(e) {
      if (e.target.files.length) {
        processFiles(e.target.files);
      }
    }
    async function processFiles(files) {
      selectedFiles = Array.from(files);
      const ok = await validateAndAnalyzeFiles(selectedFiles);
      if (!ok) {
        selectedFiles = [];
        fileInfo.style.display = 'none';
        uploadBtn.classList.add('hidden');
        uploadZone.style.display = 'block';
      }
    }

    async function imageToPdf(file) {
      const arrayBuffer = await file.arrayBuffer();
      const imgBytes = new Uint8Array(arrayBuffer);
      const pdfDoc = await PDFLib.PDFDocument.create();
      let img;
      if (file.type.includes('png')) img = await pdfDoc.embedPng(imgBytes);
      else img = await pdfDoc.embedJpg(imgBytes);
      const page = pdfDoc.addPage([img.width, img.height]);
      page.drawImage(img, { x: 0, y: 0, width: img.width, height: img.height });
      return await pdfDoc.save();
    }
    async function tiffToPdf(file) {
      const arrayBuffer = await file.arrayBuffer();
      const ifds = UTIF.decode(arrayBuffer);
      UTIF.decodeImages(arrayBuffer, ifds);
      const pdfDoc = await PDFLib.PDFDocument.create();
      for (let i = 0; i < ifds.length; i++) {
        const rgba = UTIF.toRGBA8(ifds[i]);
        const canvas = document.createElement('canvas');
        canvas.width = ifds[i].width;
        canvas.height = ifds[i].height;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(ifds[i].width, ifds[i].height);
        imageData.data.set(rgba);
        ctx.putImageData(imageData, 0, 0);
        const pngUrl = canvas.toDataURL('image/png');
        const pngBytes = await fetch(pngUrl).then(r => r.arrayBuffer());
        const img = await pdfDoc.embedPng(pngBytes);
        const page = pdfDoc.addPage([img.width, img.height]);
        page.drawImage(img, { x: 0, y: 0, width: img.width, height: img.height });
      }
      return await pdfDoc.save();
    }
    async function mergePdfs(pdfs) {
      const mergedPdf = await PDFLib.PDFDocument.create();
      for (let pdfBytes of pdfs) {
        const pdf = await PDFLib.PDFDocument.load(pdfBytes);
        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
        copiedPages.forEach(p => mergedPdf.addPage(p));
      }
      return await mergedPdf.save();
    }

    async function handleUpload() {
      if (!selectedFiles.length || isUploading) return;
      isUploading = true;
      uploadBtn.disabled = true;
      progressContainer.style.display = 'block';
      progressFilename.textContent = selectedFiles.map(f => f.name).join(', ');

      let progress = 0;
      const interval = setInterval(() => {
        progress = Math.min(progress + Math.random() * 10, 90);
        updateProgress(progress);
      }, 200);

      try {
        let pdfBuffers = [];
        for (let file of selectedFiles) {
          const ext = file.name.split('.').pop().toLowerCase();
          if (ext === 'pdf') {
            pdfBuffers.push(await file.arrayBuffer());
          } else if (ext === 'tif' || ext === 'tiff') {
            pdfBuffers.push(await tiffToPdf(file));
          } else if (['jpg', 'jpeg', 'png'].includes(ext)) {
            pdfBuffers.push(await imageToPdf(file));
          }
        }

        let finalPdf;
        if (pdfBuffers.length > 1) finalPdf = await mergePdfs(pdfBuffers);
        else finalPdf = pdfBuffers[0];

        const formData = new FormData();
        formData.append('file', new Blob([finalPdf], { type: 'application/pdf' }), 'document.pdf');
        formData.append('sides', urlParams.sides);
        if (urlParams.chat_id) formData.append('chat_id', urlParams.chat_id);
        if (urlParams.timestamp) formData.append('timestamp', urlParams.timestamp);
        if (urlParams.bot) formData.append('bot', urlParams.bot);
        if (urlParams.messageId) formData.append('messageId', urlParams.messageId);

        const resp = await fetch(WEBHOOK_URL, { method: 'POST', body: formData });
        clearInterval(interval);
        updateProgress(100);

        if (resp.ok) {
          showToast('Файл загружен', 'Отправлен на обработку');
          setTimeout(resetUI, 1000);
        } else {
          throw new Error(`Сервер: ${resp.status}`);
        }
      } catch (err) {
        clearInterval(interval);
        updateProgress(0);
        showToast('Ошибка загрузки', err.message, 'error');
      } finally {
        isUploading = false;
        uploadBtn.disabled = false;
      }
    }

    function resetUI() {
      selectedFiles = [];
      fileInfo.style.display = 'none';
      uploadBtn.classList.add('hidden');
      progressContainer.style.display = 'none';
      updateProgress(0);
      uploadZone.style.display = 'block';
    }

    function updateProgress(v) {
      progressFill.style.width = `${v}%`;
      progressPercent.textContent = `${Math.round(v)}%`;
    }

    function showToast(title, msg, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type === 'error' ? 'error' : ''}`;
      toast.innerHTML = `<div class="toast-title">${title}</div><div class="toast-message">${msg}</div>`;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.classList.add('show');
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300);
        }, 5000);
      }, 100);
    }

    init();
  </script>
</body>
</html>
